pipeline {

    // Utilisation du nouvel agent cloud Docker Python
    agent { label 'python-agent' }

    environment {
    	// R√©pertoire d'installation du scanner SonarQube d√©clar√© dans Jenkins
    	SCANNER_HOME = tool 'sonar-lcf'

    	// Nom de base de l'image Docker de l'application
    	DOCKER_IMAGE = 'flaskapp-image'

    	// Tag de version utilis√© pour l'environnement de d√©veloppement
    	DOCKER_TAG = 'dev-SNAPSHOT'
    }

    stages {

        // R√©cup√©ration du code source depuis le d√©p√¥t GitHub
        stage('Checkout') {
            steps {
                checkout scm
            }
        }

        // Ex√©cution des tests unitaires avec Pytest + g√©n√©ration du rapport de couverture avec Coverage
        stage('Run Pytest + Coverage') {
            steps {
                sh '''
                    pip3 install --break-system-packages -r requirements.txt
                    pytest
                    coverage run -m pytest
                    coverage report
                    coverage xml
                '''
            }
        }

        // Analyse de la qualit√© du code et du coverage avec SonarQube
        stage('SonarQube Analysis') {
            steps {
                withSonarQubeEnv(credentialsId: 'sonar', installationName: 'Sonar') {
                    sh "${SCANNER_HOME}/bin/sonar-scanner"
                }
            }
        }

        // Construction de l'image Docker de l'application Flask avec le tag 'dev-SNAPSHOT'
        stage('Build Docker Image') {
            steps {
                sh 'docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} .'
            }
        }

        // Scan de s√©curit√© de l'image Docker avec Trivy (affichage des vuln√©rabilit√©s sans bloquer le pipeline)
        stage('Trivy Scan') {
            steps {
                sh '''
                    trivy image \
                      --exit-code 0 \
                      --severity HIGH,CRITICAL \
                      ${DOCKER_IMAGE}:${DOCKER_TAG}
                '''
            }
        }

        // Push de l'image Docker vers le registre Harbor avec authentification
        stage('Push to Harbor') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: "token-harbor", 
                    usernameVariable: "DOCKER_USER", 
                    passwordVariable: "DOCKER_PASSWORD"
                )]) {
                    sh '''
                        echo "$DOCKER_PASSWORD" | docker login registry.lcf.io -u "$DOCKER_USER" --password-stdin
                        docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} registry.lcf.io/flask-app/${DOCKER_IMAGE}:${DOCKER_TAG}
                        docker push registry.lcf.io/flask-app/${DOCKER_IMAGE}:${DOCKER_TAG}
                    '''
                }
            }
        }

        // D√©ploiement de l'image en environnement de d√©veloppement (port 8085)
        stage('Simulate Dev Deployment') {
            steps {
                sh '''
                    docker stop flask-app-dev || true && docker rm flask-app-dev || true
                    docker run -d --name flask-app-dev --network frontend registry.lcf.io/flask-app/${DOCKER_IMAGE}:${DOCKER_TAG}
                '''
            }
        }
    }

    post {
        // Affichage d'un message de succ√®s dans Jenkins
        success {
            echo "‚úÖ D√©ploiement en DEV termin√©"
        }

        // Affichage d'un message d'√©chec dans Jenkins
        failure {
            echo "‚ùå √âchec du d√©ploiement en DEV"
        }

        // Envoi d'une notification Slack dans tous les cas (succ√®s ou √©chec)
        always {
            slackSend channel: "jenkins-lcf",
                message: "üõ†Ô∏è  Pipeline: *${env.JOB_NAME}* #${env.BUILD_NUMBER} | üîó <${env.BUILD_URL}|Voir build> | *Statut:* ${currentBuild.currentResult}"
        }
    }
}
