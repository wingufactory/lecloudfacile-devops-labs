pipeline {

    // Utilisation du nouvel agent cloud Docker Python
    agent { label 'python-agent' }

    environment {
        // Nom de l'image Docker √† manipuler
        DOCKER_IMAGE = 'flaskapp-image'
        
        // Tag source √† r√©cup√©rer depuis Harbor (image g√©n√©r√©e c√¥t√© dev)
        SNAPSHOT_TAG = 'dev-SNAPSHOT'
        
        // Tag de release transmis en param√®tre (ex : v1.0.0)
        RELEASE_TAG = "${params.RELEASE_TAG}"

        // Adresse du registre Docker (Harbor)
        REGISTRY = 'registry.lcf.io'

        // Nom du repository de l'image sur Harbor
        REPO = 'flask-app'
    }

    stages {

        // R√©cup√©ration de l'image SNAPSHOT existante depuis Harbor
        stage('Pull Snapshot Image from Harbor') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: "token-harbor",
                    usernameVariable: "DOCKER_USER",
                    passwordVariable: "DOCKER_PASSWORD"
                )]) {
                    sh '''
                        echo "$DOCKER_PASSWORD" | docker login $REGISTRY -u "$DOCKER_USER" --password-stdin
                        docker pull $REGISTRY/$REPO/${DOCKER_IMAGE}:${SNAPSHOT_TAG}
                    '''
                }
            }
        }

        // Retag de l'image SNAPSHOT avec le tag de version (RELEASE_TAG) et push sur Harbor
        stage('Tag and Push as Release') {
            steps {
                withCredentials([usernamePassword(
                    credentialsId: "token-harbor",
                    usernameVariable: "DOCKER_USER",
                    passwordVariable: "DOCKER_PASSWORD"
                )]) {
                    sh '''
                        docker tag $REGISTRY/$REPO/${DOCKER_IMAGE}:${SNAPSHOT_TAG} $REGISTRY/$REPO/${DOCKER_IMAGE}:${RELEASE_TAG}
                        docker push $REGISTRY/$REPO/${DOCKER_IMAGE}:${RELEASE_TAG}
                    '''
                }
            }
        }

        // D√©ploiement de l'image versionn√©e en environnement de production (ex√©cution locale sur port 8086)
        stage('Deploy to Production') {
            steps {
                sh '''
                    docker stop flask-app-prod || true
                    docker rm flask-app-prod || true

                    docker run -d --name flask-app-prod --network frontend $REGISTRY/$REPO/${DOCKER_IMAGE}:${RELEASE_TAG}
                '''
            }
        }
    }

    post {
        // Affichage d'un message de succ√®s dans Jenkins
        success {
            echo "‚úÖ D√©ploiement en PROD termin√© pour la release ${RELEASE_TAG}"
        }

        // Affichage d'un message d'√©chec dans Jenkins
        failure {
            echo "‚ùå √âchec du d√©ploiement en PROD pour la release ${RELEASE_TAG}"
        }

        // Envoi d'une notification Slack quel que soit le r√©sultat
        always {
            slackSend channel: "jenkins-lcf", 
                message: "üõ†Ô∏è Pipeline: *${env.JOB_NAME}* #${env.BUILD_NUMBER} | üîó <${env.BUILD_URL}|Voir build> | *Statut:* ${currentBuild.currentResult}"
        }
    }
}
